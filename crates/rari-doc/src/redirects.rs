use std::borrow::Cow;
use std::collections::{BTreeMap, HashMap, HashSet};
use std::fs::File;
use std::io::{self, BufRead, Write};
use std::path::Path;
use std::str::FromStr;
use std::sync::LazyLock;

use rari_types::globals::{content_root, content_translated_root};
use rari_types::locale::Locale;
use rari_utils::error::RariIoError;
use tracing::{error, warn};
use url::Url;

use crate::error::DocError;
use crate::resolve::url_path_to_path_buf;
use crate::utils::root_for_locale;

const REDIRECT_FILE_HEADER: &str = r#"# DO NOT EDIT THIS FILE MANUALLY.
# Use the CLI instead::
#
#    rari content add-redirect <fromURL> <toURL>
#
# FROM-URL	TO-URL
"#;

static FORBIDDEN_URL_SYMBOLS: LazyLock<HashSet<String>> =
    LazyLock::new(|| HashSet::from(["\n".to_string(), "\t".to_string()]));

static REDIRECTS: LazyLock<HashMap<String, String>> = LazyLock::new(|| {
    let mut map = HashMap::new();
    if let Some(ctr) = content_translated_root() {
        for locale in ctr
            .read_dir()
            .expect("unable to read translated content root")
            .filter_map(|dir| {
                dir.map_err(|e| {
                    error!("Error: reading translated content root: {e}");
                })
                .ok()
                .and_then(|dir| {
                    Locale::from_str(
                        dir.file_name()
                            .as_os_str()
                            .to_str()
                            .expect("invalid folder"),
                    )
                    .map_err(|e| error!("Invalid folder {:?}: {e}", dir.file_name()))
                    .ok()
                })
            })
        {
            if let Err(e) = read_redirects(
                &ctr.to_path_buf()
                    .join(locale.as_folder_str())
                    .join("_redirects.txt"),
                &mut map,
            ) {
                error!("Error reading redirects: {e}");
            }
        }
    }
    if let Err(e) = read_redirects(
        &content_root()
            .to_path_buf()
            .join(Locale::EnUs.as_folder_str())
            .join("_redirects.txt"),
        &mut map,
    ) {
        error!("Error reading redirects: {e}");
    }
    map
});

fn read_redirects(path: &Path, map: &mut HashMap<String, String>) -> Result<(), DocError> {
    let lines = read_lines(path)?;
    map.extend(lines.map_while(Result::ok).filter_map(|line| {
        if line.starts_with('#') {
            return None;
        }
        let mut from_to = line.splitn(2, '\t');
        if let (Some(from), Some(to)) = (from_to.next(), from_to.next()) {
            Some((from.to_lowercase(), to.into()))
        } else {
            None
        }
    }));
    Ok(())
}

fn read_lines<P>(filename: P) -> Result<io::Lines<io::BufReader<File>>, RariIoError>
where
    P: AsRef<Path>,
{
    let file = File::open(filename.as_ref()).map_err(|e| RariIoError {
        source: e,
        path: filename.as_ref().to_path_buf(),
    })?;
    Ok(io::BufReader::new(file).lines())
}

pub fn resolve_redirect(url: &str) -> Option<Cow<'_, str>> {
    let hash_index = url.find('#').unwrap_or(url.len());
    let (url_no_hash, hash) = (&url[..hash_index], &url[hash_index..]);
    match (
        REDIRECTS
            .get(&url_no_hash.to_lowercase())
            .map(|s| s.as_str()),
        hash,
    ) {
        (None, _) => None,
        (Some(url), hash) if url.contains('#') || hash.is_empty() => Some(Cow::Borrowed(url)),
        (Some(url), hash) => Some(Cow::Owned(format!("{url}{hash}"))),
    }
}

/// Adds new redirect pairs to the existing redirects for a specified locale.
///
/// This function performs the following steps:
///
/// 1. **Reads Existing Redirects**: It reads the current redirects from a `_redirects.txt` file specific to the provided `locale`.
/// 2. **Validates Redirect Pairs**: It separates the incoming `pairs` into those that only change the case of the target and those that represent actual redirects.
/// 3. **Removes Conflicting Redirects**: It filters out any old redirects that conflict with the new redirects being added.
/// 4. **Fixes Redirect Cases**: It updates the cases of redirect targets based on the provided `case_changed_targets`.
/// 5. **Updates Redirect Map**: It integrates the new and updated redirects into the existing redirect map.
/// 6. **Writes Back to File**: It writes the updated redirects back to the `_redirects.txt` file.
///
/// # Parameters
///
/// - `locale`: The `Locale` for which the redirects are to be added. This determines the specific `_redirects.txt` file to be read and updated.
/// - `pairs`: A slice of tuples, where each tuple consists of a `from` and `to` string representing the redirect paths.
///
/// # Returns
///
/// - `Ok(())` if the redirects are successfully added and processed.
/// - `Err(DocError)` if any errors occur during processing, such as issues with reading the redirects file or invalid locale.
///
/// # Errors
///
/// - **LocaleError**: Returned if there's an issue determining the root path for the given locale.
/// - **ReadRedirectsError**: Returned if there's an error reading the existing redirects from the `_redirects.txt` file.
/// - *Additional errors can be added based on further implementations and validations.*
pub fn add_redirects(locale: Locale, pairs: &[(String, String)]) -> Result<(), DocError> {
    // read the redirect map for the locale
    // we do not use REDIRECTS since it is static and has all the locales

    // Read the redirects file for the locale and populate the map.
    let mut map = HashMap::new();
    let path = root_for_locale(locale)?
        .to_path_buf()
        .join(locale.as_folder_str())
        .join("_redirects.txt");

    if let Err(e) = read_redirects_raw(&path, &mut map) {
        error!("Error reading redirects: {e}");
        return Err(DocError::ReadRedirectsError(e.to_string()));
    }

    // short_cut stuff, not used since it is inthe "wrong" package
    // let simplified_pairs = short_cuts(cleanPairs);

    validate_pairs(pairs, &locale)?;

    // Separate the pairs into case-only changes and proper redirects
    let (case_changed_targets, new_pairs) = separate_case_changes(pairs);
    // Remove conflicting old redirects based on the new_pairs
    let clean_pairs = remove_conflicting_old_redirects(pairs, &new_pairs);
    // Fix redirect cases based on case_changed_targets
    let clean_pairs = fix_redirects_case(&clean_pairs, &case_changed_targets);

    // Update the redirect map with the cleaned and new pairs
    for (from, to) in clean_pairs.iter() {
        map.insert(from.clone(), to.clone());
    }

    // Write the updated map back to the redirects file
    write_redirects(&path, &map)?;

    Ok(())
}

/// Validates a list of redirect pairs.
///
/// Iterates through each `(from, to)` pair and validates both URLs based on the locale.
/// If `check_exists` is `true`, it additionally checks if the `from` URL resolves to an existing file.
///
/// # Arguments
///
/// * `pairs` - A slice of `(from, to)` redirect pairs.
/// * `locale` - The locale string (e.g., "en-US").
///
/// # Returns
///
/// * `Ok(())` if all pairs are valid.
/// * `Err(DocError)` if any pair is invalid.
fn validate_pairs(pairs: &[(String, String)], locale: &Locale) -> Result<(), DocError> {
    for (from, to) in pairs {
        validate_from_url(from, locale)?;
        validate_to_url(to, locale)?;
    }
    Ok(())
}

/// Validates the 'from' URL in a redirect pair.
///
/// Ensures that the URL:
/// - Starts with a `/`.
/// - Has the correct locale prefix.
/// - Contains `/docs/`.
/// - Does not contain forbidden symbols.
/// - Does not resolve to an existing file/folder.
///
/// # Arguments
///
/// * `url` - The 'from' URL to validate.
/// * `locale` - The expected `Locale`.
///
/// # Returns
///
/// * `Ok(())` if the URL is valid.
/// * `Err(DocError)` if the URL is invalid.
fn validate_from_url(url: &str, locale: &Locale) -> Result<(), DocError> {
    let url = url.to_lowercase();
    if !url.starts_with('/') {
        return Err(DocError::InvalidRedirectFromURL(format!(
            "From-URL must start with a '/' but was '{}'",
            url
        )));
    }

    let parts: Vec<&str> = url.split('/').collect();
    if parts.len() < 3 {
        return Err(DocError::InvalidRedirectFromURL(format!(
            "From-URL '{}' does not have enough parts for locale validation.",
            url
        )));
    }

    let from_locale = parts[1];
    if from_locale != locale.as_url_str().to_lowercase() {
        return Err(DocError::InvalidRedirectFromURL(format!(
            "From-URL has locale '{}' which does not match expected locale '{}'. URL: '{}'",
            from_locale, locale, url
        )));
    }

    if !url.contains("/docs/") {
        return Err(DocError::InvalidRedirectFromURL(format!(
            "From-URL '{}' must contain '/docs/'",
            url
        )));
    }

    let valid_locales: Vec<String> = Locale::for_generic_and_spas()
        .iter()
        .map(|l| l.as_url_str().to_lowercase())
        .collect();
    if !valid_locales.contains(&from_locale.to_string()) {
        return Err(DocError::InvalidRedirectFromURL(format!(
            "Locale prefix '{}' in From-URL '{}' is not valid.",
            from_locale, url
        )));
    }

    check_url_invalid_symbols(&url)?;

    let (path, _, _, _) = url_path_to_path_buf(&url)?;
    let path = root_for_locale(*locale)?
        .join(locale.as_folder_str())
        .join(path);
    if path.exists() {
        return Err(DocError::InvalidRedirectFromURL(format!(
            "From-URL '{}' resolves to an existing folder at '{}'.",
            url,
            path.display()
        )));
    }

    Ok(())
}

/// Validates the 'to' URL in a redirect pair.
///
/// Ensures that the URL:
/// - Is either a vanity URL, an external HTTPS URL, or an internal URL that resolves correctly.
/// - Does not contain forbidden symbols.
/// - Has a valid locale prefix.
/// - Resolves to an existing file
///
/// # Arguments
///
/// * `url` - The 'to' URL to validate.
/// * `locale` - The expected `Locale`.
///
/// # Returns
///
/// * `Ok(())` if the URL is valid.
/// * `Err(DocError)` if the URL is invalid.
fn validate_to_url(url: &str, locale: &Locale) -> Result<(), DocError> {
    if is_vanity_redirect_url(url) {
        return Ok(());
    }

    if url.contains("://") {
        // External URL, validate protocol
        let parsed_url =
            Url::parse(url).map_err(|e| DocError::InvalidRedirectToURL(e.to_string()))?;
        if parsed_url.scheme() != "https" {
            return Err(DocError::InvalidRedirectToURL(format!(
                "We only redirect to 'https://', but got '{}://'",
                parsed_url.scheme()
            )));
        }
    } else if url.starts_with('/') {
        // Internal URL, perform validations

        check_url_invalid_symbols(url)?;
        validate_url_locale(url)?;

        // Split by '#', take the bare URL
        let bare_url = url.split('#').next().unwrap_or("");

        let parts: Vec<&str> = bare_url.split('/').collect();
        if parts.len() < 2 {
            return Err(DocError::InvalidRedirectToURL(format!(
                "To-URL '{}' does not have enough parts for locale validation.",
                url
            )));
        }

        let to_locale = parts[1];
        if to_locale != locale.as_url_str().to_lowercase() {
            // Different locale, no need to check path
            return Ok(());
        }

        let (path, _, _, _) = url_path_to_path_buf(&url)?;
        let path = root_for_locale(*locale)?
            .join(locale.as_folder_str())
            .join(path);
        if !path.exists() {
            return Err(DocError::InvalidRedirectToURL(format!(
                "To-URL '{}' resolves to a non-existing file/folder at '{}'.",
                url,
                path.display()
            )));
        }
    } else {
        return Err(DocError::InvalidRedirectToURL(format!(
            "To-URL '{}' has to be external (https://) or start with '/'.",
            url
        )));
    }

    Ok(())
}

fn validate_url_locale(url: &str) -> Result<(), DocError> {
    let parts: Vec<&str> = url.split('/').collect();
    if parts.len() < 3 {
        return Err(DocError::InvalidRedirectToURL(format!(
            "To-URL '{}' does not have enough parts for locale validation.",
            url
        )));
    }

    let to_locale = parts[1];
    if !Locale::for_generic_and_spas()
        .iter()
        .map(|l| l.as_url_str().to_lowercase())
        .collect::<HashSet<String>>()
        .contains(&to_locale.to_lowercase())
    {
        return Err(DocError::InvalidRedirectToURL(format!(
            "Locale prefix '{}' in To-URL '{}' is not valid.",
            to_locale, url
        )));
    }

    Ok(())
}

fn is_vanity_redirect_url(url: &str) -> bool {
    let locale_urls = Locale::for_generic_and_spas()
        .iter()
        .map(|l| format!("/{}/", l.as_url_str()))
        .collect::<HashSet<String>>();
    return locale_urls.contains(&url.to_string());
}

fn check_url_invalid_symbols(url: &str) -> Result<(), DocError> {
    for symbol in FORBIDDEN_URL_SYMBOLS.iter() {
        if url.contains(symbol) {
            let escaped_symbol = match symbol.as_str() {
                "\n" => "\\n",
                "\t" => "\\t",
                _ => symbol,
            };
            return Err(DocError::InvalidRedirectToURL(format!(
                "URL '{}' contains forbidden symbol '{}'.",
                url, escaped_symbol
            )));
        }
    }
    Ok(())
}

/// Reads redirect pairs from a file and populates the provided `HashMap`.
///
/// This function processes a file located at the specified `path`, where each line in the file
/// represents a redirect pair in the format `from\tto`. Lines that start with the `#` character
/// are treated as comments and are ignored. Only lines containing exactly two fields separated
/// by a tab (`\t`) are considered valid and are inserted into the map.
///
/// # Arguments
///
/// * `path` - A reference to a `Path` that points to the redirects file.
/// * `map` - A mutable reference to a `HashMap<String, String>` where the redirect pairs will
///           be stored. The `from` path serves as the key, and the `to` path serves as the value.
///
/// # Returns
///
/// * `Ok(())` if the redirects are successfully read and inserted into the `map`.
/// * `Err(DocError)` if an error occurs while reading the file or processing its contents.
///
/// # Errors
///
/// This function will return a `DocError` in the following situations:
///
/// * **File Read Error:** If the file at the specified `path` cannot be opened or read.
fn read_redirects_raw(path: &Path, map: &mut HashMap<String, String>) -> Result<(), DocError> {
    let lines = read_lines(path)?;
    map.extend(lines.map_while(Result::ok).filter_map(|line| {
        if line.starts_with('#') {
            return None;
        }
        let mut from_to = line.trim().splitn(2, '\t');
        if let (Some(from), Some(to)) = (from_to.next(), from_to.next()) {
            Some((from.trim().into(), to.trim().into()))
        } else {
            None
        }
    }));
    Ok(())
}

/// Writes the redirects from the HashMap to the specified file path.
///
/// Each redirect is written in the format: `from to`.
///
/// # Arguments
///
/// * `path` - The path to the `_redirects.txt` file.
/// * `map` - A reference to the HashMap containing the redirects.
///
/// # Returns
///
/// * `Ok(())` if the file is written successfully.
/// * `Err(String)` with an error message if writing fails.
fn write_redirects(path: &Path, map: &HashMap<String, String>) -> Result<(), DocError> {
    let mut file = File::create(path)?;

    // Sort the Map by making a BTreeMap from the map.
    let sorted_map: BTreeMap<_, _> = map.iter().collect();

    // Write the file header:
    file.write(REDIRECT_FILE_HEADER.as_bytes())?;

    // Write each redirect pair to the file.
    for (from, to) in sorted_map.iter() {
        writeln!(file, "{}\t{}", from, to)?
    }

    Ok(())
}

/// Separates redirect pairs into case-only changes and proper redirects.
///
/// # Arguments
///
/// * `pairs` - A slice of redirect pairs.
///
/// # Returns
///
/// * A tuple containing:
///   * A `HashSet` of references to `to` strings that only change case.
///   * A vector of references to redirect pairs that represent proper redirects.
fn separate_case_changes<'a>(
    pairs: &'a [(String, String)],
) -> (HashSet<&'a String>, Vec<&'a (String, String)>) {
    let mut case_changed_targets = HashSet::new();
    let mut new_pairs = Vec::new();

    for pair in pairs.iter() {
        if pair.0.to_lowercase() == pair.1.to_lowercase() {
            case_changed_targets.insert(&pair.1);
        } else {
            new_pairs.push(pair);
        }
    }

    (case_changed_targets, new_pairs)
}

/// Removes conflicting old redirects based on the new update pairs.
///
/// A redirect is considered conflicting if its `from` (case-insensitive) matches any `to` in `new_pairs`.
///
/// # Arguments
///
/// * `old_pairs` - A slice of original redirect pairs.
/// * `new_pairs` - A slice of new redirect pairs being added.
///
/// # Returns
///
/// * A vector of references to redirect pairs that do not conflict with `new_pairs`.
fn remove_conflicting_old_redirects<'a>(
    old_pairs: &'a [(String, String)],
    new_pairs: &[&'a (String, String)],
) -> Vec<&'a (String, String)> {
    if old_pairs.is_empty() {
        return Vec::new();
    }

    let new_targets: HashSet<String> = new_pairs.iter().map(|(_, to)| to.to_lowercase()).collect();

    old_pairs
        .iter()
        .filter(|(from, to)| {
            let conflicting_to = new_targets.contains(&from.to_lowercase());
            if conflicting_to {
                warn!(
                    "Breaking 301: removing conflicting redirect {}\t{}",
                    from, to
                );
            }
            !conflicting_to
        })
        .collect()
}

/// Fixes the case of redirect targets based on the provided `case_changed_targets`.
///
/// # Arguments
///
/// * `old_pairs` - A slice of references to redirect pairs.
/// * `case_changed_targets` - A reference to a `HashSet` of `to` strings with corrected casing.
///
/// # Returns
///
/// * A vector of redirect pairs with updated target casing.
fn fix_redirects_case<'a>(
    old_pairs: &[&'a (String, String)],
    case_changed_targets: &HashSet<&'a String>,
) -> Vec<(String, String)> {
    // Create a HashMap where the key is the lowercase version of the target (owned String),
    // and the value is the original target with corrected casing (&str).
    let new_targets: HashMap<String, &str> = case_changed_targets
        .iter()
        .map(|p| (p.to_lowercase(), p.as_str()))
        .collect();

    // Iterate over each old pair and replace the target if a case-corrected version exists.
    old_pairs
        .iter()
        .map(|&&(ref from, ref to)| {
            let target = new_targets
                .get(&to.to_lowercase())
                .copied()
                .unwrap_or(to.as_str());
            (from.clone(), target.to_string())
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    fn s(s: &str) -> String {
        s.to_string()
    }

    #[test]
    fn test_remove_conflicting_old_redirects_no_conflicts() {
        let old_pairs = vec![
            (s("/en-US/docs/A"), s("/en-US/docs/B")),
            (s("/en-US/docs/C"), s("/en-US/docs/D")),
        ];

        let update_pairs = vec![(s("/en-US/docs/E"), s("/en-US/docs/F"))];
        let update_pairs_refs: Vec<&(String, String)> = update_pairs.iter().collect();

        let expected_refs: Vec<&(String, String)> = old_pairs.iter().collect();
        let result = remove_conflicting_old_redirects(&old_pairs, &update_pairs_refs);
        assert_eq!(result, expected_refs);
    }
    #[test]
    fn test_remove_conflicting_old_redirects_with_conflicts() {
        let old_pairs = vec![
            (s("/en-US/docs/A"), s("/en-US/docs/B")),
            (s("/en-US/docs/C"), s("/en-US/docs/D")),
        ];
        let update_pairs = vec![(s("/en-US/docs/C"), s("/en-US/docs/A"))];
        let update_pairs_refs: Vec<&(String, String)> = update_pairs.iter().collect();

        let expected = vec![(s("/en-US/docs/C"), s("/en-US/docs/D"))];
        let expected_refs: Vec<&(String, String)> = expected.iter().collect();
        let result = remove_conflicting_old_redirects(&old_pairs, &update_pairs_refs);
        assert_eq!(result, expected_refs);
    }

    #[test]
    fn test_remove_conflicting_old_redirects_empty_old_pairs() {
        let old_pairs: Vec<(String, String)> = vec![];
        let update_pairs = vec![(s("/en-US/docs/A"), s("/en-US/docs/B"))];
        let update_pairs_refs: Vec<&(String, String)> = update_pairs.iter().collect();

        let expected: Vec<(String, String)> = vec![];
        let expected_refs: Vec<&(String, String)> = expected.iter().collect();
        let result = remove_conflicting_old_redirects(&old_pairs, &update_pairs_refs);
        assert_eq!(result, expected_refs);
    }

    #[test]
    fn test_remove_conflicting_old_redirects_empty_update_pairs() {
        let old_pairs = vec![
            (s("/en-US/docs/A"), s("/en-US/docs/B")),
            (s("/en-US/docs/C"), s("/en-US/docs/D")),
        ];

        let update_pairs: Vec<(String, String)> = vec![];
        let update_pairs_refs: Vec<&(String, String)> = update_pairs.iter().collect();

        let expected = old_pairs.clone();
        let expected_refs: Vec<&(String, String)> = expected.iter().collect();
        let result = remove_conflicting_old_redirects(&old_pairs, &update_pairs_refs);
        assert_eq!(result, expected_refs);
    }

    #[test]
    fn test_remove_conflicting_old_redirects_case_insensitive() {
        let old_pairs = vec![
            (s("/EN-US/docs/A"), s("/en-US/docs/B")),
            (s("/EN-US/DOCS/C"), s("/EN-US/DOCS/D")),
        ];

        let update_pairs = vec![
            (s("/en-US/docs/New1"), s("/en-US/docs/a")),
            (s("/en-US/docs/New2"), s("/en-US/docs/c")),
        ];
        let update_pairs_refs: Vec<&(String, String)> = update_pairs.iter().collect();

        let expected: Vec<(String, String)> = vec![];
        let expected_refs: Vec<&(String, String)> = expected.iter().collect();
        let result = remove_conflicting_old_redirects(&old_pairs, &update_pairs_refs);
        assert_eq!(result, expected_refs);
    }

    #[test]
    fn test_fix_redirects_case_empty_targets() {
        let old_pairs = vec![
            (s("/en-US/docs/A"), s("/en-US/docs/B")),
            (s("/en-US/docs/C"), s("/en-US/docs/D")),
        ];
        let old_pairs_ref: Vec<&(String, String)> = old_pairs.iter().collect();

        let changed_targets = HashSet::new();

        let expected = vec![
            (s("/en-US/docs/A"), s("/en-US/docs/B")),
            (s("/en-US/docs/C"), s("/en-US/docs/D")),
        ];
        let result = fix_redirects_case(&old_pairs_ref, &changed_targets);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_fix_redirects_case_changes() {
        let old_pairs = vec![
            (s("/en-US/docs/A"), s("/en-US/docs/B")),
            (s("/en-US/docs/C"), s("/en-US/docs/D")),
        ];
        let old_pairs_ref: Vec<&(String, String)> = old_pairs.iter().collect();
        let case_changed_targets = HashSet::from([s("/en-US/DOCS/B"), s("/en-US/DOCS/D")]);
        let case_changed_targets_ref = case_changed_targets.iter().collect();

        let expected = vec![
            (s("/en-US/docs/A"), s("/en-US/DOCS/B")),
            (s("/en-US/docs/C"), s("/en-US/DOCS/D")),
        ];

        let result = fix_redirects_case(&old_pairs_ref, &case_changed_targets_ref);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_fix_redirects_case_empty_old_pairs() {
        let old_pairs = vec![];
        let case_changed_targets: Vec<String> = vec![s("/en-US/DOCS/B")];
        let case_changed_targets_ref = case_changed_targets.iter().collect();

        let expected = vec![];
        let result = fix_redirects_case(&old_pairs, &case_changed_targets_ref);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_separate_case_changes_no_changes() {
        let pairs = vec![
            (s("/en-US/docs/A"), s("/en-US/docs/B")),
            (s("/en-US/docs/C"), s("/en-US/docs/D")),
        ];

        let (case_changed, proper_redirects) = separate_case_changes(&pairs);

        // All redirects are proper; no case changes.
        assert!(case_changed.is_empty(), "Expected no case changes");

        // All pairs should be in proper_redirects.
        assert_eq!(
            proper_redirects.len(),
            pairs.len(),
            "All pairs should be proper redirects"
        );
        for pair in &pairs {
            assert!(
                proper_redirects.contains(&pair),
                "Proper redirects should contain {:?}",
                pair
            );
        }
    }

    #[test]
    fn test_separate_case_changes() {
        let pairs = vec![
            (s("/en-US/docs/A"), s("/en-US/docs/a")),      // Case change
            (s("/en-US/docs/B"), s("/en-US/docs/b.html")), // Proper redirect
            (s("/en-US/docs/C"), s("/en-US/docs/C")),      // no actual change
            (s("/en-US/docs/D"), s("/en-US/docs/d.html")), // Proper redirect
        ];

        let (case_changed, proper_redirects) = separate_case_changes(&pairs);

        // There should be 2 case changes.
        assert_eq!(case_changed.len(), 2, "Expected 2 case changed targets");

        assert!(
            case_changed.contains(&&s("/en-US/docs/a")),
            "Case changed should contain '/en-US/docs/a'"
        );
        assert!(
            case_changed.contains(&&s("/en-US/docs/C")),
            "Case changed should contain '/en-US/docs/C'"
        );

        // There should be 2 proper redirects.
        assert_eq!(proper_redirects.len(), 2, "Expected 2 proper redirects");

        assert!(
            proper_redirects.contains(&&(
                "/en-US/docs/B".to_string(),
                "/en-US/docs/b.html".to_string()
            )),
            "Proper redirects should contain ('/en-US/docs/B', '/en-US/docs/b.html')"
        );

        assert!(
            proper_redirects.contains(&&(
                "/en-US/docs/D".to_string(),
                "/en-US/docs/d.html".to_string()
            )),
            "Proper redirects should contain ('/en-US/docs/D', '/en-US/docs/d.html')"
        );
    }

    #[test]
    fn test_validate_from_url_happy_path() {
        let url = "/en-US/docs/A";
        let locale = Locale::EnUs;
        let result = validate_from_url(url, &locale);
        assert!(result.is_ok());
    }

    #[test]
    fn test_validate_from_url_url_does_not_start_with_slash() {
        let url = "en-US/docs/A";
        let locale = Locale::EnUs;
        let result = validate_from_url(url, &locale);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_from_url_url_has_insufficient_parts() {
        let url = "/en-US/docs";
        let locale = Locale::EnUs;
        let result = validate_from_url(url, &locale);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_from_url_locale_mismatch() {
        let url = "/pt-BR/docs/A";
        let locale = Locale::EnUs;
        let result = validate_from_url(url, &locale);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_from_url_missing_docs_segment() {
        let url = "/en-US/A";
        let locale = Locale::EnUs;
        let result = validate_from_url(url, &locale);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_from_url_invalid_locale_prefix() {
        let url = "/hu/docs/A";
        let locale = Locale::EnUs;
        let result = validate_from_url(url, &locale);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_from_url_forbidden_symbol() {
        let url = "/en-US/docs/\nA";
        let locale = Locale::EnUs;
        let result = validate_from_url(url, &locale);
        assert!(result.is_err());
    }
}
